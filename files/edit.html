<!DOCTYPE html>
<html lang='en'>

<head>
	<title>%s | Text Adventure Game Creator</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
	<link rel="stylesheet" href="navbar.css">
	<style>
		button {
			padding: 0;
		}

		button.link {
			font: inherit;
			background-color: transparent;
			cursor: pointer;
			border: 0;
			text-decoration: underline;
		}

		.nobullet {
			list-style: none;
		}

		li {
			margin-top: 1em;
		}

		iframe {
			border: 1px solid black;
		}

		.container {
			display: flex;
			flex-wrap: wrap;
		}

		div.textarea {
			overflow-y: auto;
			border: 1px solid black;
			width: fit-content;
			height: 5em;
			resize: both;
			padding: 0.5em;
			margin-top: 1em;
		}

		textarea {
			height: auto;
			margin-top: 1em;
		}

		.description textarea {
			margin-left: 3em;
			margin-bottom: 1em;
		}

		#join-link {
			text-decoration: underline;
		}

		.container > * {
			margin: 10px;
		}
	</style>
</head>

<body>
	<div id="navbar">
		<a href="/" class="left">Home</a>
		<a href="/signin" class="right">Sign in/Sign up</a>
	</div>
	<div class="container">
		<div id="game">
			<textarea>%s</textarea>
			<h3>Locations</h3>
			<ul data-type="location">
				<li class="nobullet"><button data-type="add">Add a location</button></li>
				%s
			</ul>
			<h3>Objects</h3>
			<ul data-type="object">
				<li class="nobullet"><button data-type="add">Add an object</button></li>
				%s
			</ul>
			<button data-type="delete">Delete this game</button>
		</div>
		<iframe src="/start?game=%s" title="Play your game"></iframe>
		%s
	</div>
</body>

<script>
	"use strict";
	const game_view = document.getElementById('game');
	let opened = new Set();

	game_view.addEventListener('click', async event => {
		const path = event.composedPath();
		if (path[0] instanceof HTMLButtonElement) {
			if (path[0].classList.contains('link')) {
				if (opened.has(path[1])) {
					const lists = path[1].getElementsByTagName('ul');
					const textarea = path[1].querySelector('textarea, .textarea');
					const show = !lists[0].hidden;
					if (textarea) textarea.hidden = show;
					for (const elem of lists) elem.hidden = show;
				} else {
					opened.add(path[1]);
					const result = await ajax('GET', '/expand', {
						type: path[2].dataset.type,
						id: path[1].dataset.id
					});
					path[1].insertAdjacentHTML('beforeend', result.responseText);
				}
			} else if (path[0].dataset.type === 'delete') {
				const is_constraint_or_effect =
					/constraint|effect/.test(path[2].dataset.type);
				if (is_constraint_or_effect ||
					confirm(
						"Are you sure you want to delete this " +
						(path[2].dataset.type || 'game') +
						"? This operation cannot be undone")) {
					const obj = {
						type: path[2].dataset.type || 'game',
						obj: path[1].dataset.id,
					};
					if (is_constraint_or_effect) {
						obj.item = path[3].dataset.id;
						obj.parenttype = path[3].classList.contains('description') ?
							'description' : path[4].dataset.type;
					}
					ajax('DELETE', '/remove', obj).catch(console.error);
					if (path[2].dataset.type) path[1].remove();
					else window.location.replace("/");
				}
			} else if (path[0].dataset.type === 'add') {
				let result;
				if (/^(?:action|path|pick_up_action)$/.test(path[2].dataset.type)) {
					result = await ajax('POST', '/add', {
						type: path[2].dataset.type,
						item: path[3].dataset.id,
						parenttype: path[4].dataset.type
					});
				} else if (/constraint|effect/.test(path[2].dataset.type)) {
					result = await ajax('GET', '/constraint-or-effect', {
						type: path[2].dataset.type,
					});
				} else {
					const name = prompt(
						`Choose a name for the ${path[2].dataset.type}.`, "");
					if (!name) return;
					if (path[2].dataset.type === "location") {
						result = await ajax('POST', '/add', {
							type: 'location', name
						});
					} else if (path[2].dataset.type === "object") {
						result = await ajax('POST', '/add', {
							type: 'object', name,
							location: path[3].dataset.id
						});
					}
				}
				path[2].insertAdjacentHTML('beforeend', result.responseText);
				update_selects(path[2]);
			} else if (path[0].dataset.type === 'rename') {
				const list = path[1].getElementsByClassName('link')[0];
				const element = document.createElement('input');
				element.value = list.innerText;
				element.addEventListener('blur', end_rename);
				element.addEventListener('keypress', e => {
					if (e.key === 'Enter') e.target.blur();
				});
				list.innerHTML = '';
				list.appendChild(element);
				element.select();
			} else if (path[0].dataset.type === 'add-description-constraint') {
				const result = await ajax('GET', 'description-constraint', {
					type: path[2].dataset.type
				});
				path[1].insertAdjacentHTML('afterend', result.responseText);
				update_selects(path[2]);
			} else if (path[0].dataset.type === 'remove-description-part') {
				await ajax('DELETE', '/remove', {
					item: path[3].dataset.id,
					type: 'description',
					num: description_num(path[1])
				});
				path[1].nextElementSibling.remove();
				path[1].remove();
			} else if (path[0].dataset.type === 'add-description-part') {
				const result = await ajax('POST', '/add', {
					item: path[3].dataset.id,
					type: 'description',
					num: description_num(path[1])
				});
				path[0].insertAdjacentHTML('afterend', result.responseText);
			} else if (path[0].dataset.type === 'make-start') {
				await ajax('POST', '/setstart', { id: path[1].dataset.id });
				const old_start = document.getElementsByClassName('start')[0];
				old_start.classList.remove('start');
				old_start.getElementsByClassName("make-start")[0].hidden = false;
				path[1].classList.add('start');
				path[0].hidden = true;
			}
		}
	});

	game_view.addEventListener('change', async event => {
		const path = event.composedPath();
		if (path[0] instanceof HTMLSelectElement) {
			if (/constraint|effect/.test(path[2].dataset.type)) {
				await change_constraint_or_effect(path);
			} else if (path[1].dataset.id) await ajax('POST', '/change/item', {
				type: path[2].dataset.type,
				newitem: path[0].value,
				id: path[1].dataset.id
			});
		} else if (path[0] instanceof HTMLTextAreaElement) {
			if (path[0].id === 'start-text') {
				await ajax('POST', '/change/start-text', {
					text: path[0].value
				});
			} else if (path[0].dataset.type === 'action-description') {
				await ajax('POST', '/change/description', {
					text: path[0].value,
					id: path[1].dataset.id,
					type: path[2].dataset.type
				});
			} else await ajax('POST', '/change/description', {
				text: path[0].value,
				id: path[1].dataset.id,
				type: 'location',
			});
		} else if (path[0] instanceof HTMLInputElement) {
			if (path[0].dataset.type === 'success-checkbox') {
				await ajax('POST', '/change/item', {
					id: path[2].dataset.id,
					state: path[0].checked,
					type: 'pick_up_action'
				});
			} else if (path[1].dataset.type === 'description-constraint' ||
				/constraint|effect/.test(path[2].dataset.type)) {
				await change_constraint_or_effect(path);
			} else if (/^(?:action|path|pick_up_action)$/.test(path[3].dataset.type)) {
				await ajax('POST', '/change/win', {
					id: path[2].dataset.id,
					type: path[3].dataset.type,
					value: path[0].value
				});
			}
		}
	});

	document.getElementsByTagName('iframe')[0].addEventListener('load', resize);

	function update_selects(elem) {
		let values = new Set();
		const selects = elem.querySelectorAll('select:not(.noupdate)');
		for (const select of selects) values.add(select.value);
		for (const select of selects) for (const option of select) {
			if (option.value && !option.selected) {
				option.hidden = values.has(option.value);
			}
		}
	}

	async function end_rename(event) {
		const text = event.path[0].value;
		await ajax('POST', '/rename', {
			id: event.path[2].dataset.id,
			name: text,
			type: event.path[3].dataset.type
		});
		event.path[1].innerText = text;
	}

	async function change_constraint_or_effect(path) {
		const obj = {
			obj: path[1].dataset.id,
			item: path[3].dataset.id,
			type: path[2].dataset.type,
			parenttype: path[3].classList.contains('description') ?
				'description' : path[4].dataset.type
		}
		if (path[1].dataset.type || path[1].dataset.id > 0) {
			await ajax('DELETE', '/remove', obj);
		}

		update_selects(path[2]);
		const inputs = path[1].querySelectorAll('select, input');
		if (path[2].dataset.type === 'inventory-constraint') {
			if (!inputs[1].value) return;
			path[1].dataset.id = inputs[1].value;
			obj.obj = inputs[1].value;
			obj.value = inputs[0].value;
		} else {
			try {
				if (!inputs[0].value || !inputs[1].value) return;
			} catch (e) { }
			path[1].dataset.id = inputs[0].value;
			obj.obj = inputs[0].value;
			if (inputs[1]) obj.value = inputs[1].value;
		}
		await ajax('POST', '/add', obj);
	}

	function resize({ target }) {
		target.height = 0;
		target.height =
			target.contentDocument
				.getElementsByTagName('html')[0].scrollHeight;
	}

	function description_num(element) {
		let item = element.previousElementSibling;
		let i = 0;
		while (item) {
			if (item instanceof HTMLDivElement) i++;
			item = item.previousElementSibling;
		}
		return i;
	}

	function ajax(method, url, query) {
		return new Promise((resolve, reject) => {
			const xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = function () {
				if (this.readyState === 4) {
					(this.status < 400 ? resolve : reject)(this);
				}
			}
			let body = 'game=%s';
			for (const i in query) {
				body += `&${encodeURIComponent(i)}=${encodeURIComponent(query[i])}`
			}
			xhttp.open(method, url + (method === "POST" ? '' : '?' + body), true);
			xhttp.send(method === "POST" ? body : undefined);
		});
	}
</script>

</html>