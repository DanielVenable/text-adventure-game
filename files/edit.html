<!DOCTYPE html>
<html lang='en'>

<head>
	<title>Text adventure game</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="navbar.css">
	<style>
		button {
			padding: 0;
		}

		button.link {
			font: inherit;
			line-height: 100%;
			background-color: transparent;
			cursor: pointer;
			border: 0;
			text-decoration: underline;
		}

		.nobullet {
			list-style: none;
		}

		li {
			line-height: 300%;
		}

		iframe {
			border: 1px solid black;
		}

		.container {
			display: flex;
			flex-wrap: wrap;
		}

		div.textarea {
			overflow-y: auto;
			overflow-x: hidden;
			border: 1px solid black;
			width: fit-content;
			height: auto;
			line-height: 100%;
			resize: both;
			padding: 1em;
		}

		textarea {
			height: auto;
		}

		.description {
			margin-left: 4em;
		}
	</style>
</head>

<body>
	<div id="navbar">
		<a href="/" class="left">Home</a>
		<a href="/signin" class="right">Sign in/Sign up</a>
	</div>
	<div class="container">
		<div id="game">
			<h3>Locations</h3>
			<ul class="location">
				<li class="nobullet"><button class="add">Add a location</button></li>
				%s
			</ul>
			<h3>Objects</h3>
			<ul class="object">
				<li class="nobullet"><button class="add">Add an object</button></li>
				%s
			</ul>
			<button class="delete">Delete this game</button>
		</div>
		<p>
			<iframe src="/start?game=%s" title="Play your game"></iframe>
		</p>
	</div>
</body>

<script>
	const game_view = document.getElementById('game');
	let opened = new Set();

	game_view.addEventListener('click', async event => {
		const path = event.composedPath();
		const is_class = path[0].classList.contains.bind(path[0].classList);
		if (path[0] instanceof HTMLButtonElement) {
			if (is_class('link')) {
				if (opened.has(path[1])) {
					const lists = path[1].getElementsByTagName('ul');
					const textarea = path[1].getElementsByClassName('textarea');
					const show = !lists[0].hidden;
					if (textarea.length) textarea[0].hidden = show;
					for (const elem of lists) elem.hidden = show;
				} else {
					opened.add(path[1]);
					const result = await ajax('GET', '/expand', {
						type: path[2].classList[0],
						id: path[1].classList[0]
					});
					path[1].insertAdjacentHTML('beforeend', result.responseText);
				}
			} else if (is_class('delete')) {
				const text =
					"Are you sure you want to delete this " +
					(path[2].classList[0] || 'game') +
					"? This operation cannot be undone";
				if (confirm(text)) {
					const obj = {
						type: path[2].classList[0] || 'game',
						id: path[1].classList[0],
					};
					if (['constraint', 'effect'].includes(path[2].classList[0])) {
						obj.item = path[3].classList[0];
						obj.parenttype = path[3].classList[0];
					}
					ajax('DELETE', '/remove', obj).catch(console.error);
					if (path[2].classList[0]) {
						path[1].remove();
					} else window.location.replace("/");
				}
			} else if (is_class('add')) {
				let result;
				if (["action",
					"pick_up_action",
					"path",
					"constraint",
					"effect"]
					.includes(path[2].classList[0])) {
					result = await ajax('POST', '/add', {
						type: path[2].classList[0],
						item: path[3].classList[0],
						parenttype: path[4].classList[0]
					});
				} else {
					const name = prompt(
						`Choose a name for the ${path[2].classList[0]}.`, "");
					if (!name) return;
					if (path[2].classList[0] === "location") {
						result = await ajax('POST', '/add', {
							type: 'location', name
						});
					} else if (path[2].classList[0] === "object") {
						result = await ajax('POST', '/add', {
							type: 'object', name,
							location: path[3].classList[0]
						});
					}
				}
				path[2].insertAdjacentHTML('beforeend', result.responseText);
				update_selects(path[2]);
			} else if (is_class('rename')) {
				const list = path[1].getElementsByClassName('link')[0];
				const element = document.createElement('input');
				element.value = list.innerText;
				element.addEventListener('blur', end_rename);
				element.addEventListener('keypress', e => {
					if (e.key === 'Enter') e.target.blur()
				});
				list.innerHTML = '';
				list.appendChild(element);
				element.select();
			} else if (is_class('add-description-constraint')) {
				const result = await ajax('GET', 'description-constraint.html', {
					item: path[3].classList[0]
				});
				path[1].insertAdjacentHTML('beforebegin', result.responseText);
			} else if (is_class('remove-description-part')) {
				await ajax('DELETE', '/remove', {
					item: path[3].classList[0],
					type: 'descripiton',
					num: description_num(path[1])
				});
				path[1].nextElementSibling.remove();
				path[1].remove();
			} else if (is_class('add-description-part')) {
				const result = await ajax('POST', '/add', {
					item: path[3].classList[0],
					type: 'description',
					num: description_num(path[1])
				});
				path[0].insertAdjacentHTML('afterend', result.responseText);
			} else if (is_class('make-start')) {
				await ajax('POST', '/setstart', { id: path[1].classList[0] });
				const old_start = document.getElementsByClassName('start')[0];
				old_start.classList.remove('start');
				old_start.getElementsByClassName("make-start")[0].hidden = false;
				path[1].classList.add('start');
				path[0].hidden = true;
			}
		}
	});

	game_view.addEventListener('change', async event => {
		const path = event.composedPath();
		if (path[0] instanceof HTMLSelectElement) {
			change_item(path[0]);
		}
	});

	document.getElementsByTagName('iframe')[0].addEventListener('load', resize);

	function update_selects(elem) {
		let values = new Set();
		const selects = elem.getElementsByTagName('select');
		for (const select of selects) values.add(select.value);
		for (const select of selects) for (const option of select)
			if (option.value != 'null' && !option.selected)
				option.hidden = values.has(option.value);
	}

	async function end_rename(event) {
		const text = event.path[0].value;
		await ajax('POST', '/rename', {
			id: event.path[2].classList[0],
			name: text,
			type: event.path[3].classList[0]
		});
		event.path[1].innerText = text;
	}

	function change_description(element) {
		return ajax('POST', '/change/description', {
			id: element.parentElement.classList[0],
			text: element.value,
			type: parent_class(element, 2)
		});
	}

	function change_description_part(event) {
		return ajax('POST', '/change/description', {
			description: event.path[0].value,
			item: event.path[4].classList[0],
			type: 'location',
			num: description_num(event.path[2])
		});
	}

	function change_item(element) {
		return ajax('POST', '/change/item', {
			type: parent_class(element, 2),
			id: element.parentElement.classList[0],
			newitem: element.value
		});
	}

	function change_success(element) {
		return ajax('POST', '/change/item', {
			id: parent_class(element, 2),
			state: element.checked,
			type: 'pick_up_action'
		});
	}

	async function change_constraint_or_effect(element) {
		let obj = {
			type: element.parentElement.classList[0],
			id: element.classList[0],
			item: parent_class(element, 2),
			parenttype: parent_class(element, 3)
		}
		if (element.classList[0] !== "NaN") await ajax('DELETE', '/remove', obj);
		obj.obj = element.getElementsByTagName('select')[0].value;
		obj.state = element.getElementsByTagName('input')[0].value;
		delete obj.id;
		await ajax('POST', '/add', obj);
		element.className = element.getElementsByTagName('select')[0].value;
		update_selects(element.parentElement);
	}

	function resize(event) {
		event.target.height = 0;
		event.target.height =
			event.target.contentDocument
				.getElementsByTagName('html')[0].scrollHeight;
	}

	function parent_class(element, num) {
		if (num) {
			return parent_class(element.parentElement, num - 1);
		} else return element.classList[0];
	}

	function description_num(element) {
		let item = element.previousElementSibling;
		let i = 0;
		while (item) {
			item = item.previousElementSibling;
			if (item instanceof HTMLParagraphElement) i++;
		}
		return i;
	}

	function ajax(method, url, query) {
		return new Promise((resolve, reject) => {
			const xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = function () {
				if (this.readyState === 4)
					(this.status < 400 ? resolve : reject)(this);
			}
			let body = 'game=%s';
			for (const i in query)
				body += `&${encodeURIComponent(i)}=${encodeURIComponent(query[i])}`
			xhttp.open(method, url + (method === "POST" ? '' : '?' + body), true);
			xhttp.send(method === "POST" ? body : undefined);
		});
	}
</script>

</html>