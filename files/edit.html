<!DOCTYPE html>
<html lang='en'>

<head>
	<title>text adventure game</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="navbar.css">
	<style>
		button {
			padding: 0;
		}

		button.link {
			font: inherit;
			line-height: 100%;
			background-color: transparent;
			cursor: pointer;
			border: 0;
			text-decoration: underline;
		}

		.nobullet {
			list-style: none;
		}

		li {
			line-height: 300%;
		}

		iframe {
			border: 1px solid black;
		}

		.container {
			display: flex;
			flex-wrap: wrap;
		}

		div.textarea {
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid black;
            width: fit-content;
            height: auto;
            line-height: 100%;
            resize: both;
            padding: 1em;
		}
		
		textarea {
    		height: auto;
        }

		.description {
			margin-left: 4em;
		}
	</style>
</head>

<body>
	<div id="navbar">
		<a href="/" class="left">Home</a>
		<a href="/signin" class="right">Sign in/Sign up</a>
	</div>
	<div class="container">
		<div id="game">
			<h3>Locations</h3>
			<ul class="location">
				<li class="nobullet"><button class="add">Add a location</button></li>
				%s
			</ul>
			<h3>Objects</h3>
			<ul class="object">
				<li class="nobullet"><button class="add">Add an object</button></li>
				%s
			</ul>
			<button class="delete">Delete this game</button>
		</div>
		<p>
			<iframe src="/start?game=%s" title="Play your game"></iframe>
		</p>
	</div>
</body>

<script>
	const game = '%d';
	let opened = new Set();

	document.getElementById('game').addEventListener('click', event => {
		const is_class = event.target.classList.contains.bind(event.target.classList);
		if (event.target instanceof HTMLButtonElement) {
			if (is_class('link')) {
				expand(event.path);
			} else if (is_class('delete')) {
				remove(event.path);
			} else if (is_class('add')) {
				add(event.path);
			} else if (is_class('add-description-part')) {
				add_description_part(event.path);
			} else if (is_class('rename')) {
				rename(event.path);
			}
		}
	});

	document.getElementsByTagName('iframe')[0].addEventListener('load', resize);

	function update_selects(elem) {
		let values = new Set();
		const selects = elem.getElementsByTagName('select');
		for (const select of selects) values.add(select.value);
		for (const select of selects) for (const option of select)
			if (option.value != 'null' && !option.selected) option.hidden = values.has(option.value);
	}

	function expand(path) {
		if (opened.has(path[1])) {
			const lists = path[1].getElementsByTagName('ul');
			const textarea = path[1].getElementsByClassName('textarea');
			const show = !lists[0].hidden;
			if (textarea.length) textarea[0].hidden = show;
			for (const elem of lists) elem.hidden = show;
		} else {
			opened.add(path[1]);
			const xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = function () {
				if (this.readyState == 4 && this.status == 200)
					path[1].insertAdjacentHTML('beforeend', this.responseText);
			}
			xhttp.open("GET",
				"/expand?game=" + encodeURIComponent(game) +
				"&type=" + path[2].classList[0] +
				"&id=" + path[1].classList[0], true);
			xhttp.send();
		}
	}

	function add(path) {
		const xhttp = new XMLHttpRequest();
		xhttp.onreadystatechange = function () {
			if (this.readyState == 4 && this.status == 200)
				path[2].insertAdjacentHTML('beforeend', this.responseText);
			update_selects(path[2]);
		}
		xhttp.open("POST", "/add", true);
		if (["action", "pick_up_action", "path", "constraint", "effect"].includes(path[2].classList[0])) {
			xhttp.send(
				"game=" + game +
				"&type=" + path[2].classList[0] +
				"&item=" + path[3].classList[0] +
				"&parenttype=" + path[4].classList[0]);
		} else {
			const name = encodeURIComponent(prompt(`Choose a name for the ${path[2].classList[0]}.`, ""));
			if (name == "null" || name == "") return;
			if (path[2].classList[0] == "location") {
				const description = encodeURIComponent(prompt(`Choose a description for the location.`, ""));
				if (description == "null" || description == "") return;
				xhttp.send(
					"game=" + game +
					"&type=location&name=" + name +
					"&description=" + description);
			} else if (path[2].classList[0] == "object") {
				xhttp.send(
					"game=" + game +
					"&type=object&name=" + name +
					"&location=" + path[3].classList[0]);
			}
		}
	}

	function remove(path) {
		const text =
			"Are you sure you want to delete this " +
			(path[2].classList[0] || 'game') +
			"? This operation cannot be undone";
		if (confirm(text)) {
			const obj = {
				game,
				type: path[2].classList[0] || 'game',
				id: path[1].classList[0],
			};
			if (['constraint', 'effect'].includes(path[2].classList[0])) {
				obj.item = path[3].classList[0];
				obj.parenttype = path[3].classList[0];
			}
			ajax('DELETE', '/remove', obj).catch(console.error);
			if (path[2].classList[0]) {
				path[1].remove();
			} else window.location.replace("/");
		}
	}

	function rename(path) {
		const list = path[1].getElementsByClassName('link')[0];
		const element = document.createElement('input');
		element.value = list.innerText;
		element.addEventListener('blur', end_rename);
		element.addEventListener('keypress', e => {if (e.key === 'Enter') e.target.blur()});
		list.innerHTML = '';
		list.appendChild(element);
		element.select();
	}

	function end_rename(event) {
		const text = event.path[0].value;
		const xhttp = new XMLHttpRequest();
		xhttp.open("POST", "/rename", true);
		xhttp.send(
			"id=" + event.path[2].classList[0] +
			"&name=" + encodeURIComponent(text) +
			"&game=" + game +
			"&type=" + event.path[3].classList[0]);
		event.path[1].innerText = text;
	}

	function make_start(element) {
		const xhttp = new XMLHttpRequest();
		xhttp.open("POST", `/setstart`, true);
		xhttp.send(`id=${element.classList[0]}&game=${game}`);
		const old_start = document.getElementsByClassName('start')[0];
		old_start.classList.remove('start');
		old_start.getElementsByTagName("button")[2].hidden = false;
		element.classList.add('start');
		element.getElementsByTagName('button')[2].hidden = true;
	}

	function change_description(element) {
		const xhttp = new XMLHttpRequest();
		xhttp.open("POST", "/change/description", true);
		xhttp.send("game=" + game +
			"&id=" + element.parentElement.classList[0] +
			"&text=" + encodeURIComponent(element.value) +
			"&type=" + parent_class(element,  2));
	}

	function change_description_part(event) {
		const xhttp = new XMLHttpRequest();
		xhttp.open("POST", '/change/description', true);
		xhttp.send("game=" + game +
			"&description=" + encodeURIComponent(event.path[0].value) +
			"&item=" + event.path[4].classList[0] +
			"&type=location&num=" + description_num(event.path[2]));
	}

	function change_item(element) {
		const xhttp = new XMLHttpRequest();
		xhttp.open("POST", '/change/item', true);
		xhttp.send("game=" + game +
			"&type=" + parent_class(element,  2) +
			"&id=" + element.parentElement.classList[0] +
			"&newitem=" + element.value);
	}

	function change_success(element) {
		const xhttp = new XMLHttpRequest();
		xhttp.open("POST", '/change/item', true);
		xhttp.send("game=" + game +
			"&id=" + parent_class(element,  2) +
			"&state=" + element.checked ? 1 : 0 +
			"&type=pick_up_action");
	}

	async function change_constraint_or_effect(element) {
		let obj = {
			game,
			type: element.parentElement.classList[0],
			id: element.classList[0],
			item: parent_class(element, 2),
			parenttype: parent_class(element, 3)
		}
		if (element.classList[0] !== "NaN") await ajax('DELETE', '/remove', obj);
		obj.obj = element.getElementsByTagName('select')[0].value;
		obj.state = element.getElementsByTagName('input')[0].value;
		delete obj.id;
		await ajax('POST', '/add', obj);
		element.className = element.getElementsByTagName('select')[0].value;
		update_selects(element.parentElement);
	}

	function resize(event) {
		event.target.height = 0;
		event.target.height =
			event.target.contentDocument
				.getElementsByTagName('html')[0].scrollHeight;
	}

	async function add_description_part(path) {
		const result = await ajax('POST', '/add', {
			game,
			item: path[3].classList[0],
			type: 'description',
			num: description_num(path[1])
		});
		path[0].insertAdjacentHTML('afterend', result.responseText);
	}

	async function remove_description_part(element) {
		await ajax('DELETE', '/remove', {
			game,
			item: parent_class(element, 2),
			type:'descripiton',
			num: description_num(element)
		});
		element.nextElementSibling.remove();
		element.remove();
	}

	async function add_description_constraint(element) {
		const result = await ajax('GET', 'description-constraint.html', {
			game, item: parent_class(element[2])
		});
		element.insertAdjacentHTML('beforebegin', result.responseText);
	}

	function parent_class(element, num) {
		if (num) {
			return parent_class(element.parentElement, num - 1);
		} else return element.classList[0];
	}

	function description_num(element) {
		let item = element.previousElementSibling;
		let i = 0;
		while (item) {
			item = item.previousElementSibling;
			if (item instanceof HTMLParagraphElement) i++;
		}
		return i;
	}

	function ajax(method, url, query) {
		return new Promise((resolve, reject) => {
			const xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = function () {
				if (this.readyState === 4) 
					(this.status < 400 ? resolve : reject)(this);
			}
			const body = 
				Object.getOwnPropertyNames(query)
				.map(i => `${encodeURIComponent(i)}=${encodeURIComponent(query[i])}`)
				.join('&');
			xhttp.open(method, url + (method === "POST" ? '' : '?' + body), true);
			xhttp.send(method === "POST" ? body : undefined);
		});
	}
</script>

</html>